#构建性能分析工具

Webpack在大型项目中通常性能表现不佳，这一方面是因为JavaScript语言的单线程架构决定了Webpack的运算效率就不可能很高；另一方面是因为在大型项目中，它通常需要借助许多组件(插件、Loader)完成大量的文件读写、代码编译操作。在开发者视角中，有许多有效的性能优化方法：缓存、并发、优化文件处理步骤，但在着手优化之前，有必要简单了解Webpack打包的核心流程；了解哪些步骤比较耗时，可能会造成性能卡点；以及，如何借助一些可视化工具分析Webpack的编译性能。

### 核心流程

其中最核心的功能，1-使用适当Loader将任意类型文件转移为JavaScript代码，如将CSS代码转译成JS字符串，将多媒体文件转译为Base64代码等；2-将这些经过Loader处理的文件资源合并、打包成向下兼容的产物文件。为了实现这些，大致工作流程可以分为如下阶段：

1. 初始化阶段：
   - **初始化参数：**从配置文件、配置对象、Shell参数中读取，与默认配置结合得出最终的参数；
   - **创建编译器对象：**用上一步得到的参数创建Compiler对象；
   - **初始化编译环境：**包括注入内置插件、注册各种模块工厂、初始化RuleSet集合、加载配置的插件等。
   - **开始编译：**执行compiler对象的run方法，创建Compilation对象；
   - **确定入口：**根据配置中的`entry`找出所有的入口文件，调用`compilation.addEntry`将入口文件转换为`dependence`对象。
2. 构建阶段：
   - **编译模板(make)：**从`entry`文件开始，调用`loader`将模块转译为标准的JavaScript内容，调用JavaScript解析器将内容转换为**AST**对象，从中找出该模块依赖的模块，再**递归**处理这些依赖模块，知道所有入口依赖的文件都经过了本步骤的处理；
   - **完成模块编译：**上一步递归处理所有能触达的模块后，得到了每个模块被翻译后的内容以及它们之间的`依赖关系图`。
3. 封装阶段：
   - **合并(seal)：**根据入口和模块之间的依赖关系，组成一个个包含多个模块的`Chunk`；
   - **优化(optimization)：**对上述的Chunk施加一系列优化操作，包括：**tree-shaking、terser、scope-hoisting、压缩、Code Split**等；
   - **写入文件系统(emitAssets)**：在确定好输出内容后，根据配置确定输出的路径和文件名，吧文件内容写入到文件系统中。

可能造成性能问题的地方：

- 构建阶段：
  -  首先需要将文件引入的相对路径转换成绝对路径，这个过程可能设计多次IO操作，执行的效率取决于**文件层次的深度**；
  - 找到具体文件后，需要读入文件执行loader-runner遍历数组完成内容转译，这个过程需要执行密集CPU处理，处理的效率取决于**Loader的数量和复杂度**；
  - 需要将模块的内容解析为AST，在通过AST分析模块的依赖关系，这个过程同样需要密集CPU处理，执行效率取决于**代码复杂度**；
  - 递归处理依赖资源，执行效率取决于**模块数量**；
- 封装阶段：
  - 根据`splitChunks`配置、`entry`配置、动态模块引入语句等，确定模块和Chunk的映射关系，其中`splitChunks`相关的分包算法非常复杂，涉及大量CPU计算；
  - 根据`optimization`配置执行一系列产物优化操作，特别是`Terser`插件需要执行大量AST相关的运算，执行效率取决于**产物代码量**